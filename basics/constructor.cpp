////////////////////////////////////////////////////////////////////////////////
// in c++98
// in c++03
// in c++11, move constructor and move assignment constructor
////////////////////////////////////////////////////////////////////////////////

#include <iostream>

// Rule Of Three
//
// what functions generated by compiler ?
// default constructor, destructor, copy constructor, copy assignment constructor.
//
// what about the move constructor and move assignment constructor ?
// from effective modern cpp item 17:
// move operations are generated for classes(when needed) only if these things
// are ture:
// 1) No copy constructor are declared in the class.
// 2) No move operations are declared in the class.
// 3) No destructor is declared in the class.
//
// C++11 rules governing the special member functions are thus:
//
// Default constructor: Same rules as C++98. Generated only if the class contains
// no user-defined constructors.
//
// Destructor: same rules as C++98; sole differences is that destructors are
// nonexcept by default. As in C++98, virtual only if a base class destructor
// is virtual.
//
// Copy constructor: Same runtime bahavior as C++98; memberwise copy construction
// of non-static data members. Generated only if the class lacks use-declared
// copy constructor. Deleted if the class declares a move operation.
// Generation of this function in a class with user-declared copy assignment
// operator or destructor is deprecated.
//
// Copy assignment constructor: same as copy constructor.
//
// Move constructor and move assignment operator: Each performs memberwise
// moving of non-static data members. Generated only if the class contains
// no user-declared copy operations, move operations, or destructor.
class Test
{
public:
  Test() = default;

  ~Test() {
    std::cout << "user-defined destructor" << '\n';
    delete[] p;
  }

  // declare move constructor will prohibit copy destructor and copy assignment
  // constructor.
  Test(Test&& t) : p(std::move(t.p)) {
    std::cout << "user-declared move constructor" << '\n';
  }

private:
  char* p{nullptr};
};

Test getTest() {
  return Test();
}

int main(int argc, char *argv[])
{
  Test t1;
  Test t2;
  // Test t3 = t1; // copy constructor

  Test t4;
  // t4 = t2;      // copy assignment constructor

  Test t5(std::move(getTest())); // It's copy constructor ?

  Test t6;
  // t6 = getTest(); // it's copy assignment.

  return 0;
}

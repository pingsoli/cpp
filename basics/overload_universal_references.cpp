// don't overload the universal template function.

#include <iostream>
#include <set>
#include <string>
#include <sstream>

std::multiset<std::string> names; // global data structure

template <typename T>
void logAndAdd(T&& name) {
  std::cout << name << '\n';
  // do something
  names.emplace(std::forward<T>(name));
}

void logAndAdd(int index) {
  std::cout << "int: " << index << '\n';
  names.emplace(std::to_string(index));
}

class Person {
public:
  template <typename T>
  explicit Person(T&& name) :
    name_(std::forward<T>(name)) {}

  explicit Person(int idx) :
    name_(std::to_string(idx)) {}

private:
  std::string name_;
};

int main(int argc, char *argv[])
{
  std::string name("harry");
  logAndAdd(name);
  logAndAdd("test");
  logAndAdd(std::string("Persephone"));

  short nameIdx;
  logAndAdd(1); // better match is second

  {
    Person p1("Nancy");
    // auto cloneOfP(p1); // create new Person from p; this won't compile!

    // why ? look at the default constructor.
    // because the construct is universal template function.
    // so `auto cloneOfP(p1)` may be transformed this:
    //
    // explicit Person(Person& && name) :
    //   name_(std::forward<Person&>(name)) {}
  }

  {
    const Person p("Nancy");
    auto cloneOfP(p); // now, works fine, use the copy constructor generated by
    // compiler
    // Person(const Person& rhs) = default;
  }

  return 0;
}

///////////////////////////////////////////////////////////////////////////////
//
// Item 5: Know what functions silently writes and calls.
//
// Compilers may implicitly generate a class's default constructor, copy
// constructor, copy assignment operator, and destructor.
//
// NOTE:
// If you declared a constructor, compilers won't generate a default
// constructor.
//
///////////////////////////////////////////////////////////////////////////////

#include <iostream>

class Empty
{
};

template <typename T>
class NamedObject
{
public:
  NamedObject(const std::string& name, const T& value)
    : nameValue{name},
      objectValue{value}
  {
  }

private:
  std::string nameValue;
  T           objectValue;
};

template <typename T>
class NewNamedObject
{
public:
  NewNamedObject(std::string& name, const T& value)
    : nameValue{name},
      objectValue{value}
  {
  }

private:
  std::string& nameValue;  // this is now a reference
  const T objectValue;     // this is now const
};

int main(int argc, char** argv)
{
  /////////////////////////////////////////////////////////////////////////////
  //
  // when to generate these functiions ?
  // These functions are generated only if they are needed.
  Empty e1, e2; // default constructor
  Empty e3(e1); // copy constructor
  e1 = e2;      // copy assignment operator

  NamedObject<int> n1("hello", 5);
//  NamedObject<int> n1; // Error, no default constructor generated by compiler
  NamedObject<int> n2(n1); // Copy constructor

  // The compiler how to copy the object ?
  // nameValue variable is std::string type, so copy constructor will invoke
  // std::string copy constructor to do the job.
  // and T is int type(built-in type), so n2.objectValue will be
  // initialized by copying the bits in n1.objectValue.

  /////////////////////////////////////////////////////////////////////////////

  std::string oldDog("hello");
  std::string newDog("world");

  /////////////////////////////////////////////////////////////////////////////

  NamedObject<int> p(newDog, 2);
  NamedObject<int> s(oldDog, 14);

  p = s;

  /////////////////////////////////////////////////////////////////////////////

  NewNamedObject<int> np(newDog, 2);
  NewNamedObject<int> ns(oldDog, 14);

  np = ns; // what will happen ?

  // g++ give the error message
  // error: use of deleted function ¡®NewNamedObject<int>& NewNamedObject<int>::operator=(const NewNamedObject<int>&)¡¯)
  //
  // why did this happened ?
  // the compiler don't know how to affect valueName(is a reference)

  /////////////////////////////////////////////////////////////////////////////

  return 0;
}
